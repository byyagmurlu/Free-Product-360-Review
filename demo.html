<div id="pv-xcs4mghoz" style="width: 100%; max-width: 500px; aspect-ratio: 1; margin: 0 auto; position: relative; overflow: hidden;"></div>
<script>
(function() {
    // Injecting the full ProductViewer class logic dynamically
    const ProductViewer = class ProductViewer {
    constructor(options) {
        this.element = options.element;
        this.imagePath = options.imagePath; // Server path
        this.filePrefix = options.filePrefix || 'img';
        this.fileExtension = options.fileExtension || '.jpg';
        this.numberOfImages = options.numberOfImages || 36;
        this.imagesSrc = options.images; // Local images array

        this.sensitivity = options.sensitivity || 10; // Lower is less sensitive? No, we inverted UI. 
        // UI sends 1-200. We treat it as "pixels per frame". 
        // So sensitivity 25 means -> Drag 25px to change 1 frame.

        this.friction = options.friction || 0.95;
        this.maxZoom = options.maxZoom || 3;
        this.inertiaEnabled = options.inertia !== undefined ? options.inertia : true;
        this.withZeroPadding = options.zeroPadding !== undefined ? options.zeroPadding : true;

        // Advanced Features
        this.autoPlay = options.autoPlay || false;
        this.autoPlaySpeed = options.autoPlaySpeed || 4;
        this.showControls = options.controls || false;
        this.showFullScreen = options.fullscreen || false;

        // Notification
        this.notificationConfig = options.notification || null;

        this.startFrame = options.startFrame || 1;

        this.listeners = {};
        this.currentFrame = this.startFrame;
        this.scale = 1;
        this.panX = 0;
        this.panY = 0;
        this.velocity = 0;
        this.loadedImages = 0;
        this.images = [];
        this.isDestroyed = false;
        this.isSpinning = false; // Auto spin flag

        this.init();
    }

    init() {
        this.element.innerHTML = '';
        this.element.style.overflow = 'hidden';
        this.element.style.position = 'relative';
        this.element.style.cursor = 'grab';
        this.element.style.touchAction = 'none';
        this.element.style.userSelect = 'none';

        this.imgContainer = document.createElement('div');
        this.imgContainer.style.width = '100%';
        this.imgContainer.style.height = '100%';
        this.imgContainer.style.display = 'flex';
        this.imgContainer.style.alignItems = 'center';
        this.imgContainer.style.justifyContent = 'center';
        this.imgContainer.style.transition = 'transform 0.05s ease-out';

        this.imgElement = document.createElement('img');
        this.imgElement.style.maxWidth = '100%';
        this.imgElement.style.maxHeight = '100%';
        this.imgElement.style.objectFit = 'contain'; // Ensure it doesn't stretch weirdly
        this.imgElement.style.pointerEvents = 'none';
        this.imgElement.draggable = false;

        this.imgContainer.appendChild(this.imgElement);
        this.element.appendChild(this.imgContainer);

        if (this.notificationConfig) {
            this.createNotification();
        }

        this.loadImages();
        this.bindEvents();
        this.startPhysicsLoop();
    }

    on(event, callback) {
        if (!this.listeners[event]) this.listeners[event] = [];
        this.listeners[event].push(callback);
    }

    trigger(event, data) {
        if (this.listeners[event]) {
            this.listeners[event].forEach(cb => cb(data));
        }
    }

    setOptions(opts) {
        if (opts.sensitivity) this.sensitivity = opts.sensitivity;
        if (opts.friction) this.friction = opts.friction;
        if (opts.inertia !== undefined) this.inertiaEnabled = opts.inertia;
        if (opts.maxZoom) this.maxZoom = opts.maxZoom;
        if (opts.totalFrames) this.numberOfImages = opts.totalFrames;
        if (opts.zeroPadding !== undefined) this.withZeroPadding = opts.zeroPadding;

        // Advanced
        // AutoPlay removed

        if (opts.controls !== undefined && this.showControls !== opts.controls) {
            this.showControls = opts.controls;
            this.showControls ? this.createControlBar() : this.removeControlBar();
        }
        if (opts.fullscreen !== undefined && this.showFullScreen !== opts.fullscreen) {
            this.showFullScreen = opts.fullscreen;
            this.showFullScreen ? this.createFullScreenBtn() : this.removeFullScreenBtn();
        }

        if (!this.isSpinning && !this.inertiaEnabled) {
            // Just ensure clean state if needed
        }
    }

    destroy() {
        this.isDestroyed = true;
        this.element.innerHTML = '';
        this.element.onmousedown = null;
        this.element.onmousemove = null;
        this.element.onmouseup = null;
        this.element.ontouchstart = null;
        this.element.ontouchmove = null;
        this.element.ontouchend = null;
        this.element.onwheel = null;
        if (document.fullscreenElement) document.exitFullscreen().catch(e => { });
    }

    jumpToFrame(f) {
        this.updateFrame(f);
    }

    // Notification without Icon
    createNotification() {
        this.notifEl = document.createElement('div');
        this.notifEl.style.position = 'absolute';
        this.notifEl.style.top = '50%';
        this.notifEl.style.left = '50%';
        this.notifEl.style.transform = 'translate(-50%, -50%)';
        this.notifEl.style.pointerEvents = 'none';
        this.notifEl.style.zIndex = '20';
        this.notifEl.style.textAlign = 'center';
        this.notifEl.style.opacity = '1';
        this.notifEl.style.transition = 'opacity 0.5s';

        const text = this.notificationConfig.text || '360° View';

        this.notifEl.innerHTML = `
            <div style="background:rgba(255,255,255,0.8); padding:8px 16px; border-radius:20px; 
            box-shadow:0 2px 10px rgba(0,0,0,0.15); font-family:sans-serif; color:#333; font-size:14px;">
            ${text}
            </div>
        `;
        this.element.appendChild(this.notifEl);
    }

    updateNotification(text, visible) {
        if (visible) {
            this.notificationConfig = { text: text };
            if (!this.notifEl) this.createNotification();
            else {
                const inner = this.notifEl.querySelector('div');
                if (inner) inner.innerText = text;
                this.notifEl.style.opacity = '1';
            }
        } else {
            this.notificationConfig = null;
            if (this.notifEl) this.hideNotification();
        }
    }

    hideNotification() {
        if (this.notifEl) {
            this.notifEl.style.opacity = '0';
            setTimeout(() => {
                if (this.notifEl && this.notifEl.parentNode) this.notifEl.parentNode.removeChild(this.notifEl);
                this.notifEl = null;
            }, 500);
        }
    }

    // Control Bar
    createControlBar() {
        if (this.ctrlBar) return;
        const d = document.createElement('div');
        // Z-Index increased to 10000, explicit styling
        d.style.cssText = 'position:absolute; bottom:15px; left:50%; transform:translateX(-50%); display:flex; gap:20px; z-index:10000; background:rgba(255,255,255,0.95); padding:10px 25px; border-radius:30px; box-shadow:0 4px 15px rgba(0,0,0,0.2); border: 1px solid rgba(0,0,0,0.1);';

        // Styling for buttons - enforced dimensions and colors
        // SVG Data URIs (Dark Grey #333333)
        // Left Arrow
        const bgLeft = "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23333333'%3E%3Cpath d='M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z'/%3E%3C/svg%3E";
        // Right Arrow
        const bgRight = "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23333333'%3E%3Cpath d='M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z'/%3E%3C/svg%3E";

        const style = `border:none; background-color:transparent; cursor:pointer; width:30px; height:30px; padding:0; outline:none; -webkit-appearance:none; background-repeat:no-repeat; background-position:center; background-size:24px 24px;`;

        // Prev
        const prev = document.createElement('button');
        prev.style.cssText = style;
        prev.style.backgroundImage = `url("${bgLeft}")`;
        prev.onclick = (e) => { e.stopPropagation(); this.updateFrame(this.currentFrame - 1); };

        // Next
        const next = document.createElement('button');
        next.style.cssText = style;
        next.style.backgroundImage = `url("${bgRight}")`;
        next.onclick = (e) => { e.stopPropagation(); this.updateFrame(this.currentFrame + 1); };

        d.appendChild(prev);
        d.appendChild(next);

        this.element.appendChild(d);
        this.ctrlBar = d;
        this.playBtn = null; // No play btn to toggle icon
    }

    removeControlBar() {
        if (this.ctrlBar) {
            this.ctrlBar.remove();
            this.ctrlBar = null;
            this.playBtn = null;
        }
    }

    // Full Screen Button
    createFullScreenBtn() {
        if (this.fsBtn) return;
        const b = document.createElement('button');

        // Fullscreen Icon Data URI
        const bgFS = "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23333333'%3E%3Cpath d='M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z'/%3E%3C/svg%3E";

        // High Z-Index, white background, using background-image for icon
        b.style.cssText = `position:absolute; top:15px; right:15px; z-index:10000; background-color:rgba(255,255,255,0.9); border:none; border-radius:8px; cursor:pointer; padding:0; width:40px; height:40px; box-shadow:0 2px 8px rgba(0,0,0,0.15); background-repeat:no-repeat; background-position:center; background-size:24px 24px; background-image:url("${bgFS}");`;
        b.title = 'Tam Ekran';
        b.onclick = (e) => {
            e.stopPropagation();
            if (!document.fullscreenElement) {
                this.element.requestFullscreen().catch(err => {
                    console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                document.exitFullscreen();
            }
        };
        this.element.appendChild(b);
        this.fsBtn = b;
    }

    removeFullScreenBtn() {
        if (this.fsBtn) {
            this.fsBtn.remove();
            this.fsBtn = null;
        }
    }

    loadImages() {
        if (this.imagesSrc && this.imagesSrc.length > 0) {
            this.numberOfImages = this.imagesSrc.length;
            this.imagesSrc.forEach((src) => {
                const img = new Image();
                img.onload = () => {
                    this.loadedImages++;
                    if (this.loadedImages === 1) this.updateFrame(1);
                    if (this.loadedImages === this.numberOfImages) this.trigger('loaded');
                };
                img.onerror = () => this.trigger('error', src);
                img.src = src;
                this.images.push(img);
            });
        } else {
            for (let i = 1; i <= this.numberOfImages; i++) {
                const img = new Image();
                img.onload = () => {
                    this.loadedImages++;
                    if (this.loadedImages === 1) this.updateFrame(this.startFrame);
                    if (this.loadedImages === this.numberOfImages) this.trigger('loaded');
                };
                img.onerror = (e) => {
                    if (i < 5) this.trigger('error', img.src);
                };

                let idx = i.toString();
                if (this.withZeroPadding) {
                    idx = idx.padStart(2, '0');
                }

                img.src = `${this.imagePath}/${this.filePrefix}${idx}${this.fileExtension}`;
                this.images.push(img);
            }
        }
    }

    updateFrame(frame) {
        let normalized = frame % this.numberOfImages;
        if (normalized === 0) normalized = this.numberOfImages;
        if (normalized < 0) normalized = this.numberOfImages + normalized;

        this.currentFrame = normalized;

        if (this.images[this.currentFrame - 1] && this.images[this.currentFrame - 1].complete) {
            this.imgElement.src = this.images[this.currentFrame - 1].src;
        }

        this.trigger('index', { index: this.currentFrame, image: this.imgElement.src });
    }

    updateTransform() {
        this.imgContainer.style.transform = `scale(${this.scale}) translate(${this.panX}px, ${this.panY}px)`;
    }

    bindEvents() {
        const startHandler = (x, y, isAlt) => {
            if (this.autoPlay) this.isSpinning = false; // Stop auto play on user interact
            if (this.playBtn) this.playBtn.innerHTML = '&#9658;'; // Reset play button icon

            this.hideNotification();
            this.handleInputStart(x, y, isAlt);
        };

        this.element.onmousedown = (e) => {
            e.preventDefault();
            startHandler(e.clientX, e.clientY, e.button === 2 || e.shiftKey);
        };

        this.element.oncontextmenu = (e) => e.preventDefault();

        this.element.ontouchstart = (e) => {
            if (e.touches.length === 1) {
                startHandler(e.touches[0].clientX, e.touches[0].clientY, false);
            }
        };

        this.element.onwheel = (e) => {
            e.preventDefault();
            this.hideNotification();
            const delta = Math.sign(e.deltaY) * -0.1;
            const newScale = Math.min(Math.max(1, this.scale + delta), this.maxZoom);

            if (newScale !== this.scale) {
                this.scale = newScale;
                if (this.scale === 1) {
                    this.panX = 0;
                    this.panY = 0;
                }
                this.updateTransform();
                this.element.style.cursor = this.scale > 1 ? 'move' : 'grab';
            }
        };

        document.onmousemove = (e) => this.handleInputMove(e.clientX, e.clientY);
        document.ontouchmove = (e) => {
            if (e.touches.length === 1) {
                this.handleInputMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        };

        document.onmouseup = () => this.handleInputEnd();
        document.ontouchend = () => this.handleInputEnd();

        // Handle Fullscreen Change to reset view
        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement === this.element) {
                // Entered Fullscreen: Reset zoom/pan
                this.scale = 1;
                this.panX = 0;
                this.panY = 0;
                this.updateTransform();
                this.element.style.backgroundColor = '#fff'; // Ensure white bg in FS
            } else {
                // Exited
                this.element.style.backgroundColor = '';
                this.scale = 1; this.panX = 0; this.panY = 0; this.updateTransform();
            }
        });
    }

    handleInputStart(x, y, isAlternateBtn) {
        this.velocity = 0;

        let mode = 'rotate';
        if (this.scale > 1) {
            mode = isAlternateBtn ? 'rotate' : 'pan';
        } else {
            mode = isAlternateBtn ? 'pan' : 'rotate';
        }

        if (mode === 'pan') {
            this.isPanning = true;
            this.panningLastX = x;
            this.panningLastY = y;
            this.element.style.cursor = 'move';
        } else {
            this.isDragging = true;
            this.startX = x;
            this.lastX = x;
            this.lastMoveTime = performance.now();
            this.frameAtDragStart = this.currentFrame;
            this.element.style.cursor = 'grabbing';
            this.trigger('press');
        }
    }

    handleInputMove(x, y) {
        if (this.isPanning) {
            const deltaX = x - this.panningLastX;
            const deltaY = y - this.panningLastY;
            this.panningLastX = x;
            this.panningLastY = y;

            this.panX += deltaX / this.scale;
            this.panY += deltaY / this.scale;
            this.updateTransform();
        }
        else if (this.isDragging) {
            const now = performance.now();
            const deltaX = x - this.startX;

            const sensitivity = this.sensitivity;

            const dt = now - this.lastMoveTime;
            const moveStep = x - this.lastX;

            if (dt > 0) {
                this.velocity = moveStep / dt;
            }

            this.lastX = x;
            this.lastMoveTime = now;

            if (Math.abs(deltaX) > 0) {
                const frameChange = -Math.floor(deltaX / sensitivity);
                this.updateFrame(this.frameAtDragStart + frameChange);
            }
        }
    }

    handleInputEnd() {
        if (this.isDragging) {
            this.isDragging = false;
            this.element.style.cursor = 'grab';
            this.trigger('release');
            if (Math.abs(this.velocity) > 0.2) {
                this.isSpinning = true;
            }
        }
        if (this.isPanning) {
            this.isPanning = false;
            this.element.style.cursor = this.scale > 1 ? 'move' : 'grab';
        }
    }

    startPhysicsLoop() {
        const loop = () => {
            // Logic update to keep spinning if autoPlay OR inertia

            // 1. Handle Inertia / Velocity
            if (this.isSpinning && !this.isDragging && Math.abs(this.velocity) > 0.01 && this.inertiaEnabled) {
                this.velocity *= this.friction;

                const moveAmount = this.velocity * 16; // arbitrary scale
                if (!this.inertiaAccumulator) this.inertiaAccumulator = 0;
                this.inertiaAccumulator += moveAmount / this.sensitivity;

                if (Math.abs(this.inertiaAccumulator) >= 1) {
                    const framesToMove = -Math.round(this.inertiaAccumulator);
                    this.inertiaAccumulator -= Math.round(this.inertiaAccumulator);
                    this.updateFrame(this.currentFrame - framesToMove);
                }
            }
            // 2. Auto Play Removed

            // 3. Stop if No Velocity (and not dragging)
            else if (this.isSpinning && !this.isDragging && Math.abs(this.velocity) < 0.01) {
                this.isSpinning = false;
                this.velocity = 0;
            }
            // 3. Stop if neither (AutoPlay OFF and No Velocity)
            else if (this.isSpinning && !this.isDragging && !this.autoPlay && Math.abs(this.velocity) < 0.01) {
                this.isSpinning = false;
                this.velocity = 0;
                if (this.playBtn) this.playBtn.innerHTML = '&#9658;';
            }

            // Continue loop if spinning or moving
            if (this.isSpinning || Math.abs(this.velocity) > 0.01) {
                requestAnimationFrame(loop);
            }
        };
        loop(); // Start loop
    }

    animate360(duration = 1000) {
        this.isSpinning = false;
        this.scale = 1;
        this.panX = 0;
        this.panY = 0;
        this.updateTransform();

        const startFrame = this.currentFrame;
        const startTime = performance.now();

        const animate = (time) => {
            const elapsed = time - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const current = Math.floor(startFrame + (this.numberOfImages * progress));
            this.updateFrame(current);

            if (progress < 1) {
                this.animationId = requestAnimationFrame(animate);
            } else {
                this.animationId = null;
            }
        };
        this.animationId = requestAnimationFrame(animate);
    }
};

    new ProductViewer({
        element: document.getElementById("pv-xcs4mghoz"),
        imagePath: "https://www.comyaz.com/img/",
        filePrefix: "blue-trainers-",
        fileExtension: ".jpg",
        numberOfImages: 36,
        startFrame: 1,
        sensitivity: 10,
        friction: 0.95,
        maxZoom: 3,
        inertia: true,
        zeroPadding: true,
        notification: {"text":"360° İncelemek İçin Sürükleyin"},
        // Advanced
        controls: true,
        fullscreen: true
    });
})();
</script>
